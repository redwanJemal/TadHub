# Phase 6 Plan

## Part A: Contract Module Quick Fixes

### A1. Client object already renders in contract list & detail

**Status: Already working** — After code review, both backend and frontend are complete:
- **Backend**: `ContractsController` already enriches both list (`EnrichListWithParties`) and detail (`EnrichWithParties`) responses with `ContractClientDto { Id, NameEn, NameAr }` and `ContractWorkerDto { Id, FullNameEn, FullNameAr, WorkerCode }`
- **Frontend list** (`ContractsPage.tsx:112-116`): Client column renders `row.client?.nameEn`
- **Frontend detail** (`ContractDetailPage.tsx:165`): Client name renders in Parties card
- **DTOs** (`types.ts`): `ContractClientDto` and `ContractWorkerDto` interfaces exist with proper fields

**No changes needed** — client name + ID are already on both views. The worker and client objects are populated via BFF enrichment at the controller layer.

### A2. Contract PDF Download

Add a "Download Contract" button following the exact Worker CV PDF pattern.

#### Backend Changes

**1. New file: `src/TadHub.Api/Documents/ContractPdfData.cs`**
```csharp
public sealed record ContractPdfData(
    ContractDto Contract,
    ContractWorkerDto? Worker,
    ContractClientDto? Client,
    string TenantName,
    string? TenantNameAr,
    byte[]? TenantLogo);
```

**2. New file: `src/TadHub.Api/Documents/ContractDocument.cs`**
- QuestPDF `IDocument` implementation (follows `WorkerCvDocument` pattern exactly)
- A4 page, same font/color scheme as WorkerCvDocument
- Sections:
  - **Header**: Tenant logo + name (same as WorkerCvDocument)
  - **Contract Title**: "Employment Contract" + ContractCode + status badge
  - **Parties**: Worker name/code + Client name/ID
  - **Terms**: Contract type, start/end dates, probation/guarantee dates
  - **Financial**: Rate, rate period, currency, total value
  - **Termination** (if applicable): Terminated at, reason, by whom
  - **Notes** (if present)
  - **Footer**: "Generated by TadHub on {date}" + contract code

**3. New endpoint in `ContractsController.cs`:**
```
GET /api/v1/tenants/{tenantId}/contracts/{id}/pdf
[HasPermission("contracts.view")]
```
- Follows WorkersController.DownloadCvPdf pattern exactly
- Fetches contract + enriches with worker/client data
- Gets tenant info for branding
- Downloads tenant logo from MinIO
- Generates PDF, returns `File(bytes, "application/pdf", filename)`

#### Frontend Changes

**4. `contracts/api.ts`** — Add `downloadContractPdf()` function:
```typescript
export async function downloadContractPdf(id: string): Promise<Blob> {
  // Same pattern as downloadWorkerCvPdf in workers/api.ts
}
```

**5. `ContractDetailPage.tsx`** — Add Download button in header:
- Import `Download` icon from lucide-react
- Add `downloading` state + `handleDownloadPdf` handler (same pattern as WorkerCvPage)
- Button placed next to "Change Status" button

**6. i18n** — Add keys to `en.json` and `ar.json`:
- `actions.downloadPdf` / `actions.downloading`

---

## Part B: Document & Compliance Management Module

### Overview

New module following the established modular monolith pattern: `Document.Contracts` + `Document.Core`. Tracks worker documents (visa, medical, insurance, work permit, passport) with expiry dates, status, and compliance alerts.

### B1. Module Structure

```
src/Modules/Document/
├── Document.Contracts/
│   ├── Document.Contracts.csproj          (depends on SharedKernel)
│   ├── IDocumentService.cs                (service interface + all DTOs)
│   └── Events/
│       └── DocumentEvents.cs              (domain events)
└── Document.Core/
    ├── Document.Core.csproj               (depends on Document.Contracts, Infrastructure)
    ├── Entities/
    │   ├── WorkerDocument.cs
    │   ├── DocumentType.cs                (enum)
    │   └── DocumentStatus.cs              (enum)
    ├── Persistence/
    │   └── WorkerDocumentConfiguration.cs (EF config)
    ├── Services/
    │   └── DocumentService.cs             (implementation)
    └── Consumers/
        └── CandidateApprovedConsumer.cs   (auto-create passport doc from candidate snapshot)
```

### B2. Entities

**WorkerDocument** (extends `SoftDeletableEntity`, `IAuditable`)
```
Id, TenantId                         — from base classes
WorkerId          : Guid             — cross-module reference (no EF FK)
DocumentType      : DocumentType     — enum (see below)
DocumentNumber    : string?          — e.g., visa number, permit number
IssuedAt          : DateOnly?        — date issued
ExpiresAt         : DateOnly?        — expiry date (nullable for docs with no expiry)
Status            : DocumentStatus   — enum (see below)
IssuingAuthority  : string?          — who issued it
Notes             : string?
FileUrl           : string?          — storage key in MinIO (via TenantFileService)
CreatedBy, UpdatedBy                 — from IAuditable
```

**DocumentType** (enum)
```
Passport = 1
Visa = 2
WorkPermit = 3
MedicalCertificate = 4
InsurancePolicy = 5
EmiratesId = 6
LabourCard = 7
Other = 99
```

**DocumentStatus** (enum)
```
Valid = 1
ExpiringSoon = 2      (calculated, not stored — helper property)
Expired = 3
Revoked = 4
Pending = 5           (document in process, not yet issued)
```
Note: `ExpiringSoon` is a computed status (like TadbeerLicense.IsValid). The stored value is either `Valid`, `Expired`, `Revoked`, or `Pending`. The service layer computes "expiring soon" (within 30 days) at query time.

**Helper properties on entity** (following TadbeerLicense pattern):
```csharp
public int? DaysUntilExpiry => ExpiresAt.HasValue
    ? (ExpiresAt.Value.ToDateTime(TimeOnly.MinValue) - DateTime.UtcNow.Date).Days
    : null;

public bool IsExpired => ExpiresAt.HasValue && ExpiresAt.Value < DateOnly.FromDateTime(DateTime.UtcNow);

public bool IsExpiringSoon(int thresholdDays = 30) =>
    ExpiresAt.HasValue && !IsExpired && DaysUntilExpiry <= thresholdDays;
```

### B3. Database Configuration

**Table**: `worker_documents`

**Indexes:**
- `ix_worker_documents_tenant_id_worker_id` (for listing docs per worker)
- `ix_worker_documents_tenant_id_expires_at` (for compliance queries & background jobs)
- `ix_worker_documents_tenant_id_status`
- Unique: `ix_worker_documents_tenant_id_worker_id_document_type_document_number`

### B4. Service Interface & DTOs

**IDocumentService** (in Document.Contracts)
```csharp
// Worker document CRUD
Task<PagedList<WorkerDocumentListDto>> ListByWorkerAsync(Guid tenantId, Guid workerId, QueryParameters qp, CancellationToken ct);
Task<PagedList<WorkerDocumentListDto>> ListAllAsync(Guid tenantId, QueryParameters qp, CancellationToken ct);
Task<Result<WorkerDocumentDto>> GetByIdAsync(Guid tenantId, Guid id, CancellationToken ct);
Task<Result<WorkerDocumentDto>> CreateAsync(Guid tenantId, CreateWorkerDocumentRequest req, CancellationToken ct);
Task<Result<WorkerDocumentDto>> UpdateAsync(Guid tenantId, Guid id, UpdateWorkerDocumentRequest req, CancellationToken ct);
Task<Result> DeleteAsync(Guid tenantId, Guid id, CancellationToken ct);

// Compliance queries
Task<ComplianceSummaryDto> GetComplianceSummaryAsync(Guid tenantId, CancellationToken ct);
Task<PagedList<WorkerDocumentListDto>> GetExpiringDocumentsAsync(Guid tenantId, int withinDays, QueryParameters qp, CancellationToken ct);
```

**DTOs:**
- `WorkerDocumentDto` — full document detail
- `WorkerDocumentListDto` — lightweight for lists, includes computed `effectiveStatus` (Valid/ExpiringSoon/Expired)
- `CreateWorkerDocumentRequest` — workerId, type, number, dates, notes
- `UpdateWorkerDocumentRequest` — partial update
- `ComplianceSummaryDto` — `{ totalDocuments, valid, expiringSoon, expired, byType: [{type, valid, expiring, expired}] }`

### B5. Domain Events

```csharp
public sealed record DocumentExpiringEvent(Guid TenantId, Guid WorkerDocumentId, Guid WorkerId, string DocumentType, DateOnly ExpiresAt, int DaysRemaining) : IDomainEvent;
public sealed record DocumentExpiredEvent(Guid TenantId, Guid WorkerDocumentId, Guid WorkerId, string DocumentType) : IDomainEvent;
public sealed record DocumentCreatedEvent(Guid TenantId, Guid WorkerDocumentId, Guid WorkerId, string DocumentType) : IDomainEvent;
public sealed record DocumentUpdatedEvent(Guid TenantId, Guid WorkerDocumentId, Guid WorkerId, string DocumentType) : IDomainEvent;
```

### B6. Automatic Document Creation

**CandidateApprovedConsumer** (in Document.Core):
- Listens to `CandidateApprovedEvent` (same event that creates the Worker)
- If candidate snapshot has passport number + expiry → auto-creates a `Passport` WorkerDocument
- Idempotent (skips if passport doc already exists for that worker)

### B7. API Controller

**`DocumentsController.cs`** (in TadHub.Api)
```
Route: /api/v1/tenants/{tenantId}/workers/{workerId}/documents
```

Endpoints:
```
GET    .../documents              → List worker's documents (filterable by type, status)
GET    .../documents/{id}         → Get document detail
POST   .../documents              → Create document (with optional file upload)
PATCH  .../documents/{id}         → Update document
DELETE .../documents/{id}         → Soft delete
POST   .../documents/{id}/file    → Upload/replace document file

GET    /api/v1/tenants/{tenantId}/documents              → List ALL documents across workers
GET    /api/v1/tenants/{tenantId}/documents/expiring      → Get expiring documents (within N days)
GET    /api/v1/tenants/{tenantId}/documents/compliance     → Compliance summary
```

Permissions: `documents.view`, `documents.create`, `documents.edit`, `documents.delete`

### B8. Hangfire Background Job

**DocumentExpiryJob** — Runs daily via Hangfire recurring job:
1. Query all documents where `ExpiresAt` is within 30 days AND status is still `Valid`
2. For each, publish `DocumentExpiringEvent` (which Audit module will capture)
3. Query all documents where `ExpiresAt < today` AND status is still `Valid`
4. Update status to `Expired`, publish `DocumentExpiredEvent`

Registered in `Program.cs` or infrastructure startup:
```csharp
RecurringJob.AddOrUpdate<DocumentExpiryJob>("document-expiry-check", x => x.ExecuteAsync(CancellationToken.None), Cron.Daily);
```

### B9. Frontend

**New feature folder: `features/documents/`**
```
features/documents/
├── api.ts
├── hooks.ts
├── types.ts
├── constants.ts
├── index.ts
├── i18n/
│   ├── en.json
│   └── ar.json
├── components/
│   ├── DocumentStatusBadge.tsx
│   ├── DocumentTypeBadge.tsx
│   ├── CreateDocumentDialog.tsx
│   └── EditDocumentDialog.tsx
└── pages/
    ├── WorkerDocumentsTab.tsx      (embedded in WorkerDetailPage as new tab)
    └── CompliancePage.tsx           (standalone page for compliance overview)
```

**WorkerDetailPage integration:**
- Add a "Documents" tab alongside existing tabs
- Tab shows list of worker's documents with type badge, status badge, expiry date, actions
- "Add Document" button opens CreateDocumentDialog
- Each row: type, number, issued, expires, status (colored), file download link, edit/delete actions

**CompliancePage** (new route: `/compliance`):
- Summary cards at top: Total Documents, Valid (green), Expiring Soon (amber), Expired (red)
- DataTableAdvanced below with all documents across workers
- Filterable by: document type, status (valid/expiring/expired), worker
- Sortable by: expiry date (default ascending — soonest first), worker name, type
- Each row links to worker detail

**Sidebar navigation:**
- Add "Compliance" item under Workers section

### B10. Permissions Seeding

Add to PermissionSeeder:
```
documents.view    - View worker documents        (Tenant, order 1)
documents.create  - Add worker documents          (Tenant, order 2)
documents.edit    - Edit worker documents          (Tenant, order 3)
documents.delete  - Delete worker documents        (Tenant, order 4)
```

### B11. EF Migration

Single migration covering:
- `worker_documents` table
- All indexes

---

## Implementation Order

1. **A2** — Contract PDF download (backend endpoint + QuestPDF document + frontend button)
2. **B1-B4** — Document module scaffold (entities, DTOs, service interface + implementation)
3. **B5-B6** — Domain events + CandidateApproved consumer for auto passport creation
4. **B7** — API controller + permissions seeding
5. **B8** — Hangfire background job for expiry checking
6. **B9** — Frontend (worker documents tab + compliance page)
7. **B10-B11** — EF migration + final wiring

Each step is independently testable. Steps 2-4 can be done together as they're tightly coupled.
